{"version":3,"sources":["src/auth/passport.js","src/auth/passport.ts"],"names":["passport_jwt_1","require","services_1","Bluebird","jwt","_","exports","passportJwt","store","passport","appConfig","params","secretOrKey","getJwtConfig","secret","jwtFromRequest","ExtractJwt","fromAuthHeader","use","Strategy","token","done","options","with","find","getUsersTable","id","then","user","active","APIError","u","isAdmin","companyAlias","getMainCompany","jwtGenerator","req","res","nex","email","password","body","findAll","users","head","isEmpty","all","ServiceLib","comparePassword","resp","encryptedPassword","status","json","sign","expiresIn","catch","err","statusCode","error"],"mappings":"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","file":"passport.js","sourcesContent":["\"use strict\";\nconst passport_jwt_1 = require('passport-jwt');\nconst services_1 = require('../services');\nconst Bluebird = require('bluebird');\nconst jwt = require('jsonwebtoken');\nconst _ = require('lodash');\nexports.passportJwt = (store, passport, appConfig) => {\n    let params = {\n        secretOrKey: appConfig.getJwtConfig().secret,\n        jwtFromRequest: passport_jwt_1.ExtractJwt.fromAuthHeader()\n    };\n    passport.use(new passport_jwt_1.Strategy(params, (token, done) => {\n        // Login buscando os dados do usuário junto do client.\n        // Isso facilitará na hora de filtrar por clients e equipments do usuário logado\n        let options = { with: ['clients'] };\n        // TOdo Erro ao relacionar user com client\n        store.find(appConfig.getUsersTable(), token.id, options)\n            .then((user) => {\n            if (user) {\n                if (!user.active) {\n                    return done(new services_1.APIError('Cliente ou usuário desabilitado', 401), null);\n                }\n                else {\n                    let u = user;\n                    u.isAdmin = u.companyAlias === appConfig.getMainCompany();\n                    return done(null, u);\n                }\n            }\n            else {\n                return done(new services_1.APIError('Unauthorized', 401), null);\n            }\n        });\n    }));\n    return passport;\n};\nexports.jwtGenerator = (store, appConfig) => (req, res, nex) => {\n    let { email, password } = req.body;\n    if (email && password) {\n        let options = {\n            email: {\n                '===': email\n            }\n        };\n        return store.findAll(appConfig.getUsersTable(), options)\n            .then((users) => {\n            let user = _.head(users);\n            if (_.isEmpty(user)) {\n                throw 'O usuário não foi encontrado';\n            }\n            else if (!user.active) {\n                throw 'A conta foi desativada';\n            }\n            return Bluebird.all([user, services_1.ServiceLib.comparePassword(password, user.password)]);\n        })\n            .then((resp) => {\n            let user = resp[0];\n            let encryptedPassword = resp[1];\n            if (encryptedPassword) {\n                delete user.password;\n                return res.status(200).json(`JWT ${jwt.sign(user, appConfig.getJwtConfig().secret, { expiresIn: '3 days' })}`);\n            }\n            throw 'Invalid password';\n        })\n            .catch(err => {\n            // throw new APIError(err, 401)\n            let { statusCode, error } = new services_1.APIError(err, 401);\n            return res.status(statusCode).json(error);\n        });\n    }\n    else {\n        throw new services_1.APIError('Invalid fields', 401);\n    }\n};\n","import { ExtractJwt, Strategy, StrategyOptions } from 'passport-jwt'\nimport { IBaseUser } from '../interfaces'\nimport { Request, Response } from 'express'\nimport { APIError, ServiceLib } from '../services'\nimport { AppConfig } from '../config/app-config'\nimport * as Bluebird from 'bluebird'\nimport {Passport} from 'passport'\nimport * as jwt from 'jsonwebtoken'\nimport * as JSData from 'js-data'\nimport * as _ from 'lodash'\n\nexport const passportJwt = (store: JSData.DS, passport: Passport, appConfig: AppConfig): Passport => {\n    let params: StrategyOptions = {\n        secretOrKey: appConfig.getJwtConfig().secret,\n        jwtFromRequest: ExtractJwt.fromAuthHeader()\n    }\n\n    passport.use(new Strategy(params, (token, done) => {\n        // Login buscando os dados do usuário junto do client.\n        // Isso facilitará na hora de filtrar por clients e equipments do usuário logado\n        let options: JSData.DSFilterArg = { with: ['clients'] }\n        // TOdo Erro ao relacionar user com client\n        store.find<IBaseUser>(appConfig.getUsersTable(), token.id, options)\n            .then((user: IBaseUser) => {\n                if (user) {\n                    if (!user.active) {\n                        return done(new APIError('Cliente ou usuário desabilitado', 401), null)\n                    } else {\n                        let u = user\n                        u.isAdmin = u.companyAlias === appConfig.getMainCompany()\n                        return done(null, u)\n                    }\n                } else {\n                    return done(new APIError('Unauthorized', 401), null)\n                }\n            })\n    }))\n    return passport\n}\n\nexport const jwtGenerator = (store: JSData.DS, appConfig: AppConfig) => (req: Request, res: Response, nex: Function): JSData.JSDataPromise<Response> => {\n    let { email, password } = req.body\n    if (email && password) {\n        let options: JSData.DSFilterArg = {\n            email: {\n                '===': email\n            }\n        }\n        return store.findAll<IBaseUser>(appConfig.getUsersTable(), options)\n            .then((users: Array<IBaseUser>) => {\n                let user: IBaseUser = _.head(users)\n                if (_.isEmpty(user)) {\n                    throw 'O usuário não foi encontrado'\n                } else if (!user.active) {\n                    throw 'A conta foi desativada'\n                }\n                return Bluebird.all([user, ServiceLib.comparePassword(password, user.password)])\n            })\n            .then((resp: any) => {\n                let user: IBaseUser = resp[0]\n                let encryptedPassword: boolean = resp[1]\n                if (encryptedPassword) {\n                    delete user.password\n                    return res.status(200).json(`JWT ${jwt.sign(user, appConfig.getJwtConfig().secret, { expiresIn: '3 days' })}`)\n                }\n                throw 'Invalid password'\n            })\n            .catch(err => {\n                // throw new APIError(err, 401)\n                let { statusCode, error } = new APIError(err, 401)\n                return res.status(statusCode).json(error)\n            })\n    } else {\n        throw new APIError('Invalid fields', 401)\n    }\n}\n"]}