{"version":3,"sources":["src/models/dao.js","src/models/dao.ts"],"names":["api_error_1","require","service_lib_1","_","DAO","constructor","currentModel","joins","exclude","Error","options","with","collection","findAll","query","user","activeRecords","find","id","then","register","active","create","obj","APIError","update","ServiceLib","validateFields","Object","keys","delete","isEmpty","newObj","paginatedQuery","search","page","limit","order","_page","_limit","_order","params","assign","orderBy","offset","countResult","results","total","length","result","merge","where","exports"],"mappings":"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","file":"dao.js","sourcesContent":["\"use strict\";\nconst api_error_1 = require('../services/api-error');\nconst service_lib_1 = require('../services/service-lib');\nconst _ = require('lodash');\nclass DAO {\n    constructor(currentModel, joins = [], exclude = []) {\n        if (!currentModel) {\n            throw Error('classe não instanciada corretamente');\n        }\n        this.options = {\n            with: joins\n        };\n        this.exclude = exclude;\n        this.collection = currentModel;\n    }\n    /**\n     * busca todos os registros\n     *\n     * @param {Object} [query={}]\n     * @param {*} user\n     * @returns {JSData.JSDataPromise<Array<T>>}\n     *\n     * @memberOf DAO\n     */\n    findAll(query = {}, user) {\n        return this.collection.findAll(this.activeRecords(query), this.options);\n    }\n    /**\n     * find register by id\n     *\n     * @param {string} id\n     * @param {*} user\n     * @returns {JSData.JSDataPromise<T>}\n     *\n     * @memberOf DAO\n     */\n    find(id, user) {\n        return this.collection.find(id, this.options)\n            .then((register) => {\n            if (register.active) {\n                return register;\n            }\n            else {\n                throw 'Registro não encontrado';\n            }\n        });\n    }\n    /**\n     * create registro\n     *\n     * @param {T} obj\n     * @param {*} user\n     * @returns {JSData.JSDataPromise<T>}\n     *\n     * @memberOf DAO\n     */\n    create(obj, user) {\n        throw new api_error_1.APIError('Nao implementado', 500);\n        // return this.collection.create(obj)\n    }\n    /**\n     * altera registro\n     *\n     * @param {string} id\n     * @param {T} obj\n     * @param {*} user\n     * @returns {JSData.JSDataPromise<T>}\n     *\n     * @memberOf DAO\n     */\n    update(id, user, obj) {\n        if (!service_lib_1.ServiceLib.validateFields(obj, Object.keys(obj), this.exclude)) {\n            throw 'Alguns dados são obrigatórios, corrija-os e tente novamente';\n        }\n        return this.collection.update(id, obj);\n    }\n    /**\n     * delete registro\n     *\n     * @param {string} id\n     * @param {*} user\n     * @returns {JSData.JSDataPromise<boolean>}\n     *\n     * @memberOf DAO\n     */\n    delete(id, user) {\n        // return this.collection.destroy(id)\n        //     .then(() => true)\n        //     .catch(() => false)\n        return this.collection.find(id)\n            .then((register) => {\n            if (_.isEmpty(register)) {\n                throw 'Registro não encontrado';\n            }\n            let newObj = register;\n            newObj.active = false;\n            return this.collection.update(id, newObj).then(() => true);\n        });\n    }\n    /**\n     * realize search query using limits and page control\n     *\n     * @param {Object} search\n     * @param {*} user\n     * @param {number} [page]\n     * @param {number} [limit]\n     * @param {Array<string>} [order]\n     * @returns {JSData.JSDataPromise<IResultSearch<T>>}\n     *\n     * @memberOf DAO\n     */\n    paginatedQuery(search, user, page, limit, order) {\n        search = this.activeRecords(search);\n        let _page = page || 1;\n        let _limit = limit || 10;\n        let _order = [];\n        let params = Object.assign({}, search, {\n            orderBy: _order,\n            offset: _limit * (_page - 1),\n            limit: _limit\n        });\n        return this.collection.findAll(search)\n            .then((countResult) => {\n            return this.collection.findAll(params)\n                .then((results) => {\n                return {\n                    page: _page,\n                    total: countResult.length,\n                    result: results\n                };\n            });\n        });\n    }\n    /**\n     * Faz um merge com uma possível pesquisa para buscar somente dados ativos\n     *\n     * @param {Object} [query={}]\n     * @returns {*}\n     *\n     * @memberOf DAO\n     */\n    activeRecords(query = {}) {\n        return _.merge(query, { where: { active: { '===': true } } });\n    }\n}\nexports.DAO = DAO;\n","import { IDAO, IResultSearch } from '../interfaces'\nimport { APIError } from '../services/api-error'\nimport { ServiceLib } from '../services/service-lib'\nimport * as JSData from 'js-data'\nimport {IBaseUser} from '../interfaces/ibase-user'\nimport {IBaseModel} from '../interfaces/ibase-model'\nimport * as _ from 'lodash'\n\nexport class DAO<T extends IBaseModel> implements IDAO<T> {\n    public collection: JSData.DSResourceDefinition<T>\n    public options: JSData.DSFilterArg\n    public exclude: Array<string>\n\n    constructor(currentModel: JSData.DSResourceDefinition<T>, joins: any[] = [], exclude: Array<string> = []) {\n        if (!currentModel) {\n            throw Error('classe não instanciada corretamente')\n        }\n        this.options = {\n            with: joins\n        }\n        this.exclude = exclude\n        this.collection = currentModel\n    }\n\n    /**\n     * busca todos os registros\n     * \n     * @param {Object} [query={}]\n     * @param {*} user\n     * @returns {JSData.JSDataPromise<Array<T>>}\n     * \n     * @memberOf DAO\n     */\n    public findAll(query: Object = {}, user: IBaseUser): JSData.JSDataPromise<Array<T>> {\n        return this.collection.findAll(this.activeRecords(query), this.options)\n    }\n\n    /**\n     * find register by id\n     * \n     * @param {string} id\n     * @param {*} user\n     * @returns {JSData.JSDataPromise<T>}\n     * \n     * @memberOf DAO\n     */\n    public find(id: string, user: IBaseUser): JSData.JSDataPromise<T> {\n        return this.collection.find(id, this.options)\n            .then((register: T) => {\n                if (register.active) {\n                    return register\n                } else {\n                    throw 'Registro não encontrado'\n                }\n            })\n    }\n\n    /**\n     * create registro\n     * \n     * @param {T} obj\n     * @param {*} user\n     * @returns {JSData.JSDataPromise<T>}\n     * \n     * @memberOf DAO\n     */\n    public create(obj: T, user: IBaseUser): JSData.JSDataPromise<T> {\n        throw new APIError('Nao implementado', 500)\n        // return this.collection.create(obj)\n    }\n\n    /**\n     * altera registro\n     * \n     * @param {string} id\n     * @param {T} obj\n     * @param {*} user\n     * @returns {JSData.JSDataPromise<T>}\n     * \n     * @memberOf DAO\n     */\n    public update(id: string, user: IBaseUser, obj: T): JSData.JSDataPromise<T> {\n        if (!ServiceLib.validateFields(obj, Object.keys(obj), this.exclude)) {\n            throw 'Alguns dados são obrigatórios, corrija-os e tente novamente'\n        }\n        return this.collection.update(id, obj)\n    }\n\n    /**\n     * delete registro\n     * \n     * @param {string} id\n     * @param {*} user\n     * @returns {JSData.JSDataPromise<boolean>}\n     * \n     * @memberOf DAO\n     */\n    public delete(id: string, user: IBaseUser): JSData.JSDataPromise<boolean> {\n        // return this.collection.destroy(id)\n        //     .then(() => true)\n        //     .catch(() => false)\n\n        return this.collection.find(id)\n            .then((register: T) => {\n                if (_.isEmpty(register)) {\n                    throw 'Registro não encontrado'\n                }\n                let newObj: T = register\n                newObj.active = false\n                return this.collection.update(id,newObj).then(() => true)\n            })\n    }\n\n    /**\n     * realize search query using limits and page control\n     * \n     * @param {Object} search\n     * @param {*} user\n     * @param {number} [page]\n     * @param {number} [limit]\n     * @param {Array<string>} [order]\n     * @returns {JSData.JSDataPromise<IResultSearch<T>>}\n     * \n     * @memberOf DAO\n     */\n    paginatedQuery(\n        search: Object, user: IBaseUser, page?: number, limit?: number, order?: Array<string>\n    ): JSData.JSDataPromise<IResultSearch<T>> {\n        search = this.activeRecords(search)\n        let _page: number = page || 1\n        let _limit: number = limit || 10\n        let _order: string[] = []\n        let params = Object.assign({}, search, {\n            orderBy: _order,\n            offset: _limit * (_page - 1),\n            limit: _limit\n        })\n\n        return this.collection.findAll(search)\n            .then((countResult) => {\n                return this.collection.findAll(params)\n                    .then((results) => {\n                        return {\n                            page : _page,\n                            total: countResult.length,\n                            result: results\n                        } as IResultSearch<T>\n                    })\n            })\n    }\n\n    /**\n     * Faz um merge com uma possível pesquisa para buscar somente dados ativos\n     * \n     * @param {Object} [query={}]\n     * @returns {*}\n     * \n     * @memberOf DAO\n     */\n    private activeRecords(query: Object = {}): any {\n        return _.merge(query, { where: { active: { '===': true } } })\n    }\n}\n"]}