{"version":3,"sources":["src/services/service-lib.js","src/services/service-lib.ts"],"names":["shortid","require","_","EmailValidator","bcrypt","bcryptjs","crypto","characters","ServiceLib","constructor","config","generateId","generate","emailValidator","email","validate","validateFields","obj","fields","exclude","allCorrect","forEach","el","indexOf","isEmpty","toString","hashPassword","password","hash","genSaltSync","comparePassword","encryptedPassword","compare","fieldsUpValidator","fieldsObj","fieldsUp","newObj","field","encrypt","text","cipher","createCipher","getCryptoAlgorithm","getCryptoPassword","crypted","update","final","decrypt","decipher","createDecipher","dec","generateToken","data","expiration","Date","setDate","getDate","getExpirationDays","JSON","stringify","exports"],"mappings":"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","file":"service-lib.js","sourcesContent":["\"use strict\";\nconst shortid = require('shortid');\nconst _ = require('lodash');\nconst EmailValidator = require('email-validator');\n/**\n * passwordCrypto\n */\nconst bcrypt = require('bcrypt-then');\nconst bcryptjs = require('bcryptjs');\n/**\n * Cripto\n */\nconst crypto = require('crypto');\n/**\n * shortid config chars\n */\nshortid.characters('0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$@');\nclass ServiceLib {\n    constructor(config) {\n        this.config = config;\n    }\n    /**\n     * Gera id\n     * @returns {string}\n     */\n    static generateId() {\n        return shortid.generate();\n    }\n    /**\n     * is valid email?\n     *\n     * @param {string} email\n     * @returns {boolean}\n     */\n    static emailValidator(email) {\n        return EmailValidator.validate(email);\n    }\n    /**\n     * O 'obj' terá seus dados validado em relação aos campos contidos em 'fields'\n     * Exceto os campos contidos em 'exclude'\n     *\n     * @param {*} obj\n     * @param {Array<string>} fields\n     * @param {Array<string>} [exclude=[]]\n     * @returns {Boolean}\n     *\n     */\n    static validateFields(obj, fields, exclude = []) {\n        let allCorrect = true;\n        fields.forEach(el => {\n            if (_.indexOf(exclude, el) === -1) {\n                allCorrect = allCorrect && !_.isEmpty(_.toString(obj[el]));\n            }\n        });\n        return allCorrect;\n    }\n    static hashPassword(password) {\n        return bcrypt.hash(password, bcryptjs.genSaltSync(10));\n    }\n    static comparePassword(password, encryptedPassword) {\n        return bcrypt.compare(password, encryptedPassword);\n    }\n    /**\n     * Através de 'fieldsUp' um novo objeto é formado e somente os campos ditos nele serão atualizados.\n     * Ou seja, permitindo que campos que não podem ser alterados fiquem seguros e inalterados na atualização.\n     *\n     * @param {*} obj\n     * @param {Array<string>} fieldsObj\n     * @param {Array<string>} fieldsUp\n     * @returns {*}\n     *\n     */\n    static fieldsUpValidator(obj, fieldsObj, fieldsUp) {\n        let newObj = {};\n        fieldsUp.forEach(field => {\n            if (_.indexOf(fieldsObj, field) !== -1) {\n                newObj[field] = obj[field];\n            }\n        });\n        return newObj;\n    }\n    encrypt(text) {\n        let cipher = crypto.createCipher(this.config.getCryptoAlgorithm(), this.config.getCryptoPassword());\n        let crypted = cipher.update(text, 'utf8', 'hex');\n        crypted += cipher.final('hex');\n        return crypted;\n    }\n    decrypt(text) {\n        let decipher = crypto.createDecipher(this.config.getCryptoAlgorithm(), this.config.getCryptoPassword());\n        let dec = decipher.update(text, 'hex', 'utf8');\n        dec += decipher.final('utf8');\n        return dec;\n    }\n    generateToken(email) {\n        let data = {\n            email: email,\n            expiration: new Date()\n        };\n        // Expire on confg days\n        data.expiration.setDate(data.expiration.getDate() + this.config.getExpirationDays());\n        return this.encrypt(JSON.stringify(data));\n    }\n}\nexports.ServiceLib = ServiceLib;\n","import {AppConfig} from '../config/app-config'\nimport * as shortid from 'shortid'\nimport * as _ from 'lodash'\nimport * as EmailValidator from 'email-validator'\n/**\n * passwordCrypto\n */\nconst bcrypt = require('bcrypt-then')\nconst bcryptjs = require('bcryptjs')\n/**\n * Cripto\n */\nconst crypto = require('crypto')\n/**\n * shortid config chars\n */\nshortid.characters('0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$@')\n\nexport class ServiceLib {\n\n    config: AppConfig\n\n    constructor(config: AppConfig) {\n        this.config = config\n\n    }\n\n    /**\n     * Gera id\n     * @returns {string}\n     */\n    static generateId() {\n        return shortid.generate()\n    }\n\n    /**\n     * is valid email?\n     *\n     * @param {string} email\n     * @returns {boolean}\n     */\n    static emailValidator(email: string): boolean {\n        return EmailValidator.validate(email)\n    }\n\n    /**\n     * O 'obj' terá seus dados validado em relação aos campos contidos em 'fields'\n     * Exceto os campos contidos em 'exclude'\n     *\n     * @param {*} obj\n     * @param {Array<string>} fields\n     * @param {Array<string>} [exclude=[]]\n     * @returns {Boolean}\n     *\n     */\n    static validateFields(obj: any, fields: Array<string>, exclude: Array<string> = []): boolean {\n        let allCorrect: boolean = true\n\n        fields.forEach(el => {\n            if (_.indexOf(exclude, el) === -1) {\n                allCorrect = allCorrect && !_.isEmpty(_.toString(obj[el]))\n            }\n        })\n\n        return allCorrect\n    }\n\n    static hashPassword(password: string): string {\n        return bcrypt.hash(password, bcryptjs.genSaltSync(10))\n    }\n\n    static comparePassword(password: string, encryptedPassword: string): boolean {\n        return bcrypt.compare(password, encryptedPassword)\n    }\n\n    /**\n     * Através de 'fieldsUp' um novo objeto é formado e somente os campos ditos nele serão atualizados.\n     * Ou seja, permitindo que campos que não podem ser alterados fiquem seguros e inalterados na atualização.\n     *\n     * @param {*} obj\n     * @param {Array<string>} fieldsObj\n     * @param {Array<string>} fieldsUp\n     * @returns {*}\n     *\n     */\n    static fieldsUpValidator(obj: any, fieldsObj: Array<string>, fieldsUp: Array<string>): any {\n        let newObj: any = {}\n\n        fieldsUp.forEach(field => {\n            if (_.indexOf(fieldsObj, field) !== -1) {\n                newObj[field] = obj[field]\n            }\n        })\n\n        return newObj\n    }\n    encrypt(text: string) {\n        let cipher = crypto.createCipher(this.config.getCryptoAlgorithm(), this.config.getCryptoPassword())\n        let crypted = cipher.update(text, 'utf8', 'hex')\n        crypted += cipher.final('hex')\n        return crypted\n    }\n\n    decrypt(text: string) {\n        let decipher = crypto.createDecipher(this.config.getCryptoAlgorithm(), this.config.getCryptoPassword())\n        let dec = decipher.update(text, 'hex', 'utf8')\n        dec += decipher.final('utf8')\n        return dec\n    }\n\n    generateToken(email: string): string {\n        let data: any = {\n            email,\n            expiration: new Date()\n        }\n        // Expire on confg days\n        data.expiration.setDate(data.expiration.getDate() + this.config.getExpirationDays())\n        return this.encrypt(JSON.stringify(data))\n    }\n}\n"]}